/**
 * Akash Chat API Proxy - Multi-Account & API Key Enhanced
 * 高性能、可维护的OpenAI兼容接口，支持图像生成功能
 * @version 3.1.0
 */

// 核心配置
const CONFIG = {
    // 服务信息
    SERVICE: {
        NAME: 'AkashGen Proxy Enhanced',
        PROVIDER: {
            NAME: 'Musifei',
            URL: 'https://musifei.live',
        },
        VERSION: '3.1.0',
    },

    // API配置
    AKASH_API: {
        BASE_URL: 'https://chat.akash.network/api',
        COOKIES: (Deno.env.get('AKASH_COOKIES') || '').split(',').filter(Boolean), // 从环境变量获取多个Cookie，逗号分隔, 务必配置!
        COOKIE_ROTATION_INTERVAL_MS: 1800000, // 30 minutes for cookie rotation
        ENDPOINTS: {
            CHAT: '/chat',
            IMAGE_STATUS: '/image-status',
            MODELS: '/models', // 添加 models endpoint
        },
    },

    // OpenAI API Key 配置
    OPENAI_API_KEY: Deno.env.get('OPENAI_API_KEY') || null, // 如果设置了OPENAI_API_KEY环境变量，则启用API Key验证

    // 图像生成配置
    IMAGE: {
        POLL_INTERVAL_MS: 2000,
        MAX_POLL_ATTEMPTS: 30,
        TIMEOUT_MS: 60000,
        REGEX:
            /<image_generation>\s*jobId='([^']+)'\s*prompt='([^']*)'\s*negative='([^']*)'\s*<\/image_generation>/,
        MESSAGES: {
            GENERATING: '正在生成图像...',
            FAILED: '图像生成失败或超时。请稍后重试。',
            CREDIT_FORMAT:
                '*Generated by **{model}** in {time}s, provided by [**{provider}**]({url}).*',
            UPLOAD_FAILED: '图像上传图床失败，请稍后重试。', // 新增上传失败消息
        },
    },

    // 默认参数
    DEFAULTS: {
        MODEL: 'DeepSeek-R1',
        SYSTEM_MESSAGE: 'You are a helpful assistant.',
        TEMPERATURE: 0.6,
        TOP_P: 0.95,
        MAX_TOKENS: 4096,
    },

    // 支持的模型列表 (从API获取，本地配置不再需要)
    MODELS: [
        { id: 'Meta-Llama-3-3-70B-Instruct', name: 'Meta-Llama-3-3-70B-Instruct' },
        { id: 'DeepSeek-R1', name: 'DeepSeek-R1' },
        {
            id: 'Meta-Llama-3-1-405B-Instruct-FP8',
            name: 'Meta-Llama-3-1-405B-Instruct-FP8',
        },
        { id: 'Meta-Llama-3-2-3B-Instruct', name: 'Meta-Llama-3-2-3B-Instruct' },
        {
            id: 'Meta-Llama-3-1-8B-Instruct-FP8',
            name: 'Meta-Llama-3-1-8B-Instruct-FP8',
        },
        { id: 'mistral', name: 'mistral' },
        { id: 'nous-hermes2-mixtral', name: 'nous-hermes2-mixtral' },
        { id: 'dolphin-mixtral', name: 'dolphin-mixtral' },
        { id: 'AkashGen', name: 'AkashGen' },
    ],

    // HTTP状态码
    HTTP: {
        OK: 200,
        BAD_REQUEST: 400,
        UNAUTHORIZED: 401, // 添加 Unauthorized 状态码
        NOT_FOUND: 404,
        METHOD_NOT_ALLOWED: 405,
        SERVER_ERROR: 500,
        SERVICE_UNAVAILABLE: 503,
    },

    // 性能优化
    PERFORMANCE: {
        BUFFER_SIZE: 16384, // 调整缓冲区大小
        CHUNK_SIZE: 8192, // 调整分块大小
    },

    // 日志级别
    LOG_LEVEL: {
        ERROR: 0,
        WARN: 1,
        INFO: 2,
        DEBUG: 3,
    },

    // 当前日志级别
    CURRENT_LOG_LEVEL: 2, // INFO

    // CORS配置 - 生产环境请修改为你的域名
    ALLOWED_ORIGINS: Deno.env.get('ALLOWED_ORIGINS')?.split(',') || ['*'], // 允许的来源，从环境变量获取，多个用逗号分隔
    // 常量
    STATUS_COMPLETED: 'completed',
    STATUS_FAILED: 'failed',
    RETRY_STATUS_CODES: [429, 500, 503], // 需要重试的状态码
} as const;

// 缓存常用的请求头
const HEADERS = {
    JSON: { 'Content-Type': 'application/json' },
    SSE: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        Connection: 'keep-alive',
    },
    CORS: {
        'Access-Control-Allow-Origin': CONFIG.ALLOWED_ORIGINS.join(','), // 使用配置的允许来源
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
} as const;

// 初始化API头信息 - Cookie 会动态设置
let AKASH_HEADERS = {
    'Content-Type': 'application/json',
} as const;

// Cookie 轮换索引
let currentCookieIndex = 0;
let lastCookieRotation = Date.now();

// 文本编码器
const encoder = new TextEncoder();

/**
 * 日志工具
 */
const Logger = {
    error: (...args: unknown[]) => {
        if (CONFIG.CURRENT_LOG_LEVEL >= CONFIG.LOG_LEVEL.ERROR) {
            console.error(`[ERROR] ${new Date().toISOString()}:`, ...args);
        }
    },
    warn: (...args: unknown[]) => {
        if (CONFIG.CURRENT_LOG_LEVEL >= CONFIG.LOG_LEVEL.WARN) {
            console.warn(`[WARN] ${new Date().toISOString()}:`, ...args);
        }
    },
    info: (...args: unknown[]) => {
        if (CONFIG.CURRENT_LOG_LEVEL >= CONFIG.LOG_LEVEL.INFO) {
            console.info(`[INFO] ${new Date().toISOString()}:`, ...args);
        }
    },
    debug: (...args: unknown[]) => {
        if (CONFIG.CURRENT_LOG_LEVEL >= CONFIG.LOG_LEVEL.DEBUG) {
            console.debug(`[DEBUG] ${new Date().toISOString()}:`, ...args);
        }
    },
} as const;

/**
 * 检查并轮换 Cookie
 */
function rotateCookie() {
    if (CONFIG.AKASH_API.COOKIES.length <= 1) return; // 如果只有一个或没有 Cookie，则不轮换
    if (Date.now() - lastCookieRotation < CONFIG.AKASH_API.COOKIE_ROTATION_INTERVAL_MS) return;

    currentCookieIndex = (currentCookieIndex + 1) % CONFIG.AKASH_API.COOKIES.length;
    updateAkashHeaders();
    lastCookieRotation = Date.now();
    Logger.info(`轮换 Cookie，当前使用 Cookie 索引: ${currentCookieIndex}`);
}

/**
 * 更新 Akash 请求头中的 Cookie
 */
function updateAkashHeaders() {
    AKASH_HEADERS = {
        ...AKASH_HEADERS,
        Cookie: CONFIG.AKASH_API.COOKIES[currentCookieIndex] || '',
    };
}

// 初始化请求头 Cookie
updateAkashHeaders();

/**
 * 验证 API Key
 * @param {Request} request - 客户端请求
 * @returns {string|null} API Key 或 null 如果验证失败
 * @throws {ValidationError} 如果API Key 无效
 */
async function validateApiKey(request: Request): Promise<string | null> {
    const apiKey = request.headers.get('Authorization')?.replace('Bearer ', '') || null;

    if (CONFIG.OPENAI_API_KEY) { // 如果配置了 OPENAI_API_KEY，则需要验证
        if (!apiKey || apiKey !== CONFIG.OPENAI_API_KEY) {
            Logger.warn(`API Key 验证失败: ${apiKey}`);
            throw new ValidationError('Invalid API key');
        }
        return apiKey;
    }
    return apiKey; // 如果没有配置 OPENAI_API_KEY，则跳过验证
}


/**
 * 主入口点 - 处理所有传入的请求
 */
Deno.serve(async (request: Request): Promise<Response> => {
    try {
        return await handleRequest(request);
    } catch (error) {
        return handleGlobalError(error);
    }
});

/**
 * 路由处理器 - 将请求分发到相应的处理函数
 * @param {Request} request - 客户端请求
 * @returns {Promise<Response>} 响应
 */
async function handleRequest(request: Request): Promise<Response> {
    // 处理OPTIONS请求（CORS预检）
    if (request.method === 'OPTIONS') {
        return handleCorsRequest();
    }

    const url = new URL(request.url);
    const { pathname: path } = url;
    const method = request.method;
    const requestId = crypto.randomUUID(); // 生成请求ID
    Logger.info(`[${requestId}] Request received: ${method} ${path}`); // 记录请求ID

    // 路由表 - 将路径和方法映射到处理函数
    const ROUTES: {
        [key: string]: { [key: string]: (request: Request) => Promise<Response> };
    } = {
        '/v1/models': {
            GET: handleModelsRequest,
        },
        '/v1/chat/completions': {
            POST: handleChatCompletionsRequest,
        },
        '/health': {
            GET: handleHealthCheck,
        },
    };

    // 查找匹配的路由
    const route = ROUTES[path];
    if (!route) {
        Logger.warn(`[${requestId}] Path not found: ${path}`); // 记录请求ID
        return createJsonResponse(
            { error: 'Not Found', message: `Path ${path} not found` },
            { status: CONFIG.HTTP.NOT_FOUND },
        );
    }

    // 查找匹配的方法处理器
    const handler = route[method];
    if (!handler) {
        Logger.warn(`[${requestId}] Method not allowed: ${method} for ${path}`); // 记录请求ID
        return createJsonResponse(
            {
                error: 'Method Not Allowed',
                message: `Method ${method} not allowed for ${path}`,
            },
            { status: CONFIG.HTTP.METHOD_NOT_ALLOWED },
        );
    }

    // 调用处理函数
    try {
        return await handler(request);
    } finally {
        Logger.info(`[${requestId}] Request completed.`); // 记录请求ID
    }
}

/**
 * 处理CORS预检请求
 * @returns {Response} CORS响应
 */
function handleCorsRequest(): Response {
    return new Response(null, {
        status: CONFIG.HTTP.OK,
        headers: HEADERS.CORS,
    });
}

/**
 * 处理健康检查请求
 * @returns {Response} 健康状态响应
 */
function handleHealthCheck(): Response {
    return createJsonResponse({
        status: 'ok',
        version: CONFIG.SERVICE.VERSION,
        timestamp: new Date().toISOString(),
    });
}

/**
 * 处理模型列表请求
 * @param {Request} request - 客户端请求
 * @returns {Response} 包含模型列表的响应
 */
async function handleModelsRequest(request: Request): Promise<Response> {
    try {
        await validateApiKey(request); // 验证 API Key
        rotateCookie(); // 轮换 Cookie

        const response = await fetchWithRetry(
            `${CONFIG.AKASH_API.BASE_URL}${CONFIG.AKASH_API.ENDPOINTS.MODELS}`,
            {
                method: 'GET',
                headers: AKASH_HEADERS,
            },
            { retries: 2, delay: 1000 },
        );

        if (!response.ok) {
            const errorText = await response.text();
            Logger.error(
                `模型列表请求失败, Akash API 错误: ${response.status}`,
                errorText,
            );
            throw new ApiError(
                `模型列表请求失败: Akash API 响应状态 ${response.status}`,
                response.status,
            );
        }

        const akashModels = await response.json();
        const timestamp = Math.floor(Date.now() / 1000);

        const modelList = {
            object: 'list',
            data: akashModels.models.map((model: any) => ({ // 确保正确访问 models 数组
                id: model.id,
                object: 'model',
                created: timestamp,
                owned_by: 'organization',
            })),
        };
        return createJsonResponse(modelList);

    } catch (error) {
        if (error instanceof ValidationError) {
            return createJsonResponse(
                { error: error.message },
                { status: CONFIG.HTTP.UNAUTHORIZED }, // 返回 401 Unauthorized
            );
        }
        throw error; // 抛出其他错误让全局错误处理器处理
    }
}


/**
 * 处理聊天完成请求
 * @param {Request} request - 客户端请求
 * @returns {Promise<Response>} 流式响应
 */
async function handleChatCompletionsRequest(request: Request): Promise<Response> {
    let requestId: string;
    try {
        requestId = crypto.randomUUID();
        await validateApiKey(request); // 验证 API Key
        rotateCookie(); // 轮换 Cookie

        // 解析和验证请求数据
        const requestData = await parseAndValidateRequest(request);

        // 创建会话上下文
        const context = createSessionContext(requestData);
        // 添加请求ID到会话上下文
        context.requestId = requestId;
        Logger.info(`[${requestId}] 创建会话: ${context.chatId}, 模型: ${context.model}`);

        // 准备Akash请求数据
        const akashRequestData = prepareAkashRequestData(requestData, context);

        // 发送请求到Akash API
        const akashResponse = await fetchWithRetry(
            `${CONFIG.AKASH_API.BASE_URL}${CONFIG.AKASH_API.ENDPOINTS.CHAT}`,
            {
                method: 'POST',
                headers: AKASH_HEADERS,
                body: JSON.stringify(akashRequestData),
            },
            { retries: 2, delay: 1000 },
        );

        // 检查响应状态
        if (!akashResponse.ok) {
            const errorText = await akashResponse.text();
            Logger.error(
                `[${requestId}] Akash API错误: ${akashResponse.status}`,
                errorText,
            );
            throw new ApiError(
                `Akash API responded with status ${akashResponse.status}: ${errorText}`,
                akashResponse.status,
            );
        }

        return createStreamResponse(akashResponse, context);
    } catch (error) {
        if (error instanceof ValidationError) {
            Logger.warn(`[${requestId}] 验证错误: ${error.message}`);
            return createJsonResponse(
                { error: error.message },
                { status: CONFIG.HTTP.UNAUTHORIZED }, // 返回 401 Unauthorized
            );
        }

        if (error instanceof ApiError) {
            return createJsonResponse(
                { error: error.message },
                { status: error.statusCode },
            );
        }

        // 其他未知错误
        Logger.error(`[${requestId}] Chat completions error:`, error);
        return createJsonResponse(
            { error: `服务器错误: ${error.message}` },
            { status: CONFIG.HTTP.SERVER_ERROR },
        );
    }
}

/**
 * 解析并验证请求数据
 * @param {Request} request - 客户端请求
 * @returns {Promise<Object>} 验证后的请求数据
 * @throws {ValidationError} 如果请求数据无效
 */
async function parseAndValidateRequest(request: Request): Promise<any> {
    let data;
    try {
        data = await request.json();
    } catch (error) {
        throw new ValidationError('无效的JSON请求体');
    }

    // 验证必要字段
    if (
        !data.messages ||
        !Array.isArray(data.messages) ||
        data.messages.length === 0
    ) {
        throw new ValidationError('请求必须包含非空的messages数组');
    }

    // 验证消息格式
    for (const msg of data.messages) {
        if (!msg.role || !msg.content) {
            throw new ValidationError('每条消息必须包含role和content字段');
        }

        // 验证角色值
        const validRoles = ['system', 'user', 'assistant', 'function'];
        if (!validRoles.includes(msg.role)) {
            throw new ValidationError(
                `无效的消息角色: ${msg.role}。有效值: ${validRoles.join(', ')}`,
            );
        }
    }

    // 验证模型
    if (data.model && !CONFIG.MODELS.some((m) => m.id === data.model)) {
        Logger.warn(`请求使用了未知模型: ${data.model}，将使用默认模型`);
        data.model = CONFIG.DEFAULTS.MODEL;
    }

    // 验证temperature
    if (data.temperature !== undefined) {
        if (
            typeof data.temperature !== 'number' ||
            data.temperature < 0 ||
            data.temperature > 2
        ) {
            throw new ValidationError('temperature必须是0到2之间的数值');
        }
    }

    // 验证top_p
    if (data.top_p !== undefined) {
        if (typeof data.top_p !== 'number' || data.top_p < 0 || data.top_p > 1) {
            throw new ValidationError('top_p必须是0到1之间的数值');
        }
    }

    return data;
}

/**
 * 创建会话上下文
 * @param {Object} requestData - 请求数据
 * @returns {Object} 会话上下文
 */
function createSessionContext(requestData: any): any {
    return {
        chatId: generateUniqueId(),
        model: requestData.model || CONFIG.DEFAULTS.MODEL,
        timestamp: Math.floor(Date.now() / 1000),
        stream: requestData.stream !== false, // 默认为true
        temperature: requestData.temperature ?? CONFIG.DEFAULTS.TEMPERATURE,
        topP: requestData.top_p ?? CONFIG.DEFAULTS.TOP_P,
        maxTokens: requestData.max_tokens ?? CONFIG.DEFAULTS.MAX_TOKENS,
        finalChunkSent: false, // 确保只发送一次 finalChunk
        requestId: '', // 添加请求ID
    };
}

/**
 * 生成唯一ID
 * @returns {string} 唯一ID
 */
function generateUniqueId(): string {
    return crypto.randomUUID().replace(/-/g, '').slice(0, 16);
}

/**
 * 准备发送到Akash的请求数据
 * @param {Object} requestData - 客户端请求数据
 * @param {Object} context - 会话上下文
 * @returns {Object} 准备好的请求数据
 */
function prepareAkashRequestData(requestData: any, context: any): any {
    return {
        id: context.chatId,
        messages: requestData.messages,
        model: context.model,
        system: requestData.system_message || CONFIG.DEFAULTS.SYSTEM_MESSAGE,
        temperature: context.temperature,
        topP: context.topP,
        maxTokens: context.maxTokens,
    };
}

/**
 * 带重试功能的fetch
 * @param {string} url - 请求URL
 * @param {Object} options - fetch选项
 * @param {Object} [retryOptions={}] - 重试选项
 * @param {number} [retryOptions.retries=3] - 最大重试次数
 * @param {number} [retryOptions.delay=500] - 重试间隔(ms)
 * @returns {Promise<Response>} 响应
 */
async function fetchWithRetry(
    url: string,
    options: any,
    retryOptions: { retries?: number; delay?: number } = {},
): Promise<Response> {
    const { retries = 3, delay = 500 } = retryOptions;
    let lastError;

    for (let attempt = 0; attempt <= retries; attempt++) {
        try {
            if (attempt > 0) {
                Logger.info(`重试第 ${attempt}/${retries} 次请求: ${url}`);
            }

            const response = await fetch(url, options);

            // 只对特定状态码进行重试
            if (!CONFIG.RETRY_STATUS_CODES.includes(response.status)) {
                return response;
            }

            lastError = new ApiError(
                `Server responded with status ${response.status}`,
                response.status,
            );
        } catch (error) {
            lastError = error;
        }

        // 最后一次尝试失败，不再等待
        if (attempt === retries) break;

        // 指数退避策略
        const waitTime = delay * Math.pow(2, attempt);
        await sleep(waitTime);
    }

    throw lastError;
}

/**
 * 创建流式响应
 * @param {Response} akashResponse - Akash API响应
 * @param {Object} context - 会话上下文
 * @returns {Response} 流式响应
 */
function createStreamResponse(akashResponse: Response, context: any): Response {
    const reader = akashResponse.body!.getReader();
    const decoder = new TextDecoder();

    // 图像处理状态
    const imageState = createImageState();

    const stream = new ReadableStream({
        async start(controller) {
            try {
                await processStream(reader, decoder, controller, context, imageState);
            } catch (error) {
                Logger.error(`[${context.requestId}] Stream processing error:`, error);
                sendErrorChunk(
                    controller,
                    context,
                    `处理流时发生错误: ${error.message}`,
                );
            } finally {
                //   controller.close();
                // 确保在processStream处理后关闭controller
            }
        },
    });

    const headers = {
        ...HEADERS.SSE,
        ...HEADERS.CORS,
    };

    return new Response(stream, { headers });
}

/**
 * 创建图像状态对象
 * @returns {Object} 图像状态对象
 */
function createImageState(): any {
    return {
        jobId: null,
        prompt: null,
        negative: null,
        processing: false,
        processed: false,
    };
}

/**
 * 处理流数据
 * @param {ReadableStreamDefaultReader} reader - 流读取器
 * @param {TextDecoder} decoder - 文本解码器
 * @param {ReadableStreamDefaultController} controller - 流控制器
 * @param {Object} context - 会话上下文
 * @param {Object} imageState - 图像状态
 */
async function processStream(
    reader: ReadableStreamDefaultReader,
    decoder: TextDecoder,
    controller: ReadableStreamDefaultController,
    context: any,
    imageState: any,
) {
    let buffer = '';

    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
                if (!line.trim()) continue;
                await processLine(line, controller, context, imageState);
            }
        }

        // 处理最后一行（如果有）
        if (buffer.trim()) {
            await processLine(buffer, controller, context, imageState);
        }
    } catch (error) {
        Logger.error(`[${context.requestId}] Error in stream processing:`, error);
        sendErrorChunk(controller, context, '流处理中断');
    } finally {
        // 确保发送最终消息
        if (!imageState.processing || imageState.processed) {
            sendFinalChunk(controller, context);
        }
        controller.close(); // 确保关闭controller
    }
}

/**
 * 处理响应中的单行数据
 * @param {string} line - 响应行
 * @param {ReadableStreamDefaultController} controller - 流控制器
 * @param {Object} context - 会话上下文
 * @param {Object} imageState - 图像处理状态
 */
async function processLine(
    line: string,
    controller: ReadableStreamDefaultController,
    context: any,
    imageState: any,
) {
    // 尝试解析消息类型和数据
    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) return;

    const type = line.substring(0, colonIndex);
    const msgData = line.substring(colonIndex + 1);

    switch (type) {
        case '0': // 内容块
            await processContentChunk(msgData, controller, context, imageState);
            break;

        case 'e': // 结束标记
        case 'd': // 断开连接
            if (!imageState.processing || imageState.processed) {
                sendFinalChunk(controller, context);
            }
            break;

        default:
            // 忽略未知类型
            break;
    }
}

/**
 * 处理内容块
 * @param {string} msgData - 消息数据
 * @param {ReadableStreamDefaultController} controller - 流控制器
 * @param {Object} context - 会话上下文
 * @param {Object} imageState - 图像处理状态
 */
async function processContentChunk(
    msgData: string,
    controller: ReadableStreamDefaultController,
    context: any,
    imageState: any,
) {
    const processedData = processMsgData(msgData);
    const isAkashGen = context.model === 'AkashGen';

    // 处理AkashGen模型的图像生成
    if (isAkashGen && !imageState.processing) {
        const imageMatch = processedData.match(CONFIG.IMAGE.REGEX);

        if (imageMatch) {
            imageState.jobId = imageMatch[1];
            imageState.prompt = imageMatch[2];
            imageState.negative = imageMatch[3];
            imageState.processing = true;

            Logger.info(
                `[${context.requestId}] 开始图像生成: jobId=${imageState.jobId}, prompt="${imageState.prompt}"`,
            );

            // 发送初始消息 - 根据要求不包含prompt
            sendChunk(controller, context, `${CONFIG.IMAGE.MESSAGES.GENERATING}\n\n`);

            // 轮询图像状态并处理结果
            await processImageGeneration(controller, context, imageState);

            // 跳过原始图像生成标记
            return;
        }
    }

    // 如果不是图像生成或已处理，正常发送内容
    if (!imageState.processing || imageState.processed) {
        sendChunk(controller, context, processedData);
    }
}
/**
 * 上传图片到新叶图床并获取URL
 * @param {string} base64Image - base64 格式的图片数据
 * @returns {Promise<string|null>} 图片URL 或 null (上传失败)
 */
async function uploadImageToXinyew(base64Image: string): Promise<string | null> {
    try {
        // 移除 base64 数据前缀 (如果有)
        const base64Data = base64Image.startsWith('data:') ? base64Image.split(',')[1] : base64Image;
        const imageBlob = base64ToBlob(base64Data, 'image/webp'); // 假设图床支持 webp，并尝试上传 webp

        const formData = new FormData();
        formData.append('file', imageBlob, 'image.webp'); // 文件名可以自定义

        const response = await fetch('https://api.xinyew.cn/api/jdtc', {
            method: 'POST',
            body: formData,
        });

        if (!response.ok) {
            Logger.error(`图床上传失败: ${response.status} ${response.statusText}`);
            return null;
        }

        const result = await response.json();

        // 修改成功判断条件，检查 errno 是否为 0，并且 data.url 是否存在
        if (result && result.errno === 0 && result.data && result.data.url) {
            Logger.info(`图片成功上传到图床: ${result.data.url}, 消息: ${result.message}`); // 记录消息
            return result.data.url; // 返回 data.url
        } else {
            Logger.error(`图床上传失败，返回数据:`, result);
            return null;
        }

    } catch (error) {
        Logger.error('上传图片到图床时发生错误:', error);
        return null;
    }
}

/**
 * base64 字符串转 Blob 对象
 * @param {string} base64 - base64 字符串
 * @param {string} contentType - 内容类型 (例如 'image/webp')
 * @returns {Blob} Blob 对象
 */
function base64ToBlob(base64: string, contentType: string): Blob {
    const byteCharacters = atob(base64);
    const byteArrays = [];
    for (let offset = 0; offset < byteCharacters.length; offset += 512) {
        const slice = byteCharacters.slice(offset, offset + 512);
        const byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        byteArrays.push(byteArray);
    }
    return new Blob(byteArrays, { type: contentType });
}


/**
 * 处理图像生成过程
 * @param {ReadableStreamDefaultController} controller - 流控制器
 * @param {Object} context - 会话上下文
 * @param {Object} imageState - 图像处理状态
 */
async function processImageGeneration(
    controller: ReadableStreamDefaultController,
    context: any,
    imageState: any,
    retryCount: number = 0 // 新增重试计数器
) {
    try {
        // 使用Promise.race实现超时保护
        const imageData = await Promise.race([
            pollImageStatus(imageState.jobId),
            createTimeout(CONFIG.IMAGE.TIMEOUT_MS, '图像生成超时'),
        ]);

        if (
            imageData &&
            imageData.status === CONFIG.STATUS_COMPLETED &&
            imageData.result
        ) {
            Logger.info(
                `[${context.requestId}] 图像生成成功 (Cookie Index: ${currentCookieIndex}), jobId=${imageState.jobId}, 耗时=${imageData.elapsed_time}s`, // 添加 Cookie Index 日志
            );

            let imageUrl: string | null = null;
            try {
                imageUrl = await uploadImageToXinyew(imageData.result); // 上传图片到图床
            } catch (uploadError) {
                Logger.error(`图像上传到图床失败:`, uploadError);
                imageUrl = null; // 上传失败，imageUrl 设为 null
            }

            if (imageUrl) {
                // 创建Markdown格式的图像响应，使用图床URL
                const markdownContent = createImageMarkdown(imageState, { ...imageData, result: imageUrl }, context);
                sendChunk(controller, context, markdownContent);
            } else {
                // 图床上传失败，发送失败消息
                const errorMsg = `\n\n${CONFIG.IMAGE.MESSAGES.UPLOAD_FAILED}\n${CONFIG.IMAGE.MESSAGES.FAILED}`;
                sendChunk(controller, context, errorMsg);
            }

        } else {
            // 图像生成失败
            const statusText = imageData ? imageData.status : '未知';
            Logger.warn(
                `[${context.requestId}] 图像生成失败 (Cookie Index: ${currentCookieIndex}), jobId=${imageState.jobId}, status=${statusText}, 重试次数: ${retryCount}`, // 添加 Cookie Index 和重试次数日志
            );

            // 检查是否还有更多 cookies 可以尝试，并且没有达到最大重试次数
            if (CONFIG.AKASH_API.COOKIES.length > 1 && retryCount < CONFIG.AKASH_API.COOKIES.length) {
                rotateCookie(); // 轮换 Cookie
                Logger.info(`轮换 Cookie 后重试图像生成，当前 Cookie Index: ${currentCookieIndex}, jobId=${imageState.jobId}, 重试次数: ${retryCount + 1}`);
                // 递归调用 processImageGeneration 进行重试，增加重试计数
                await processImageGeneration(controller, context, imageState, retryCount + 1);
                return; // 提前返回，避免发送失败消息
            }


            const errorMsg = `\n\n${CONFIG.IMAGE.MESSAGES.FAILED}\n状态: ${statusText}`;
            sendChunk(controller, context, errorMsg);
        }
    } catch (error) {
        Logger.error(`[${context.requestId}] Image processing error (Cookie Index: ${currentCookieIndex}), 重试次数: ${retryCount}:`, error); // 添加 Cookie Index 和重试次数日志
        sendErrorChunk(controller, context, `图像处理错误: ${error.message}`);
    } finally {
        imageState.processed = true;
        if (!context.finalChunkSent) {
            sendFinalChunk(controller, context);
            context.finalChunkSent = true;
        }
    }
}

/**
 * 创建图像的Markdown格式
 * @param {Object} imageState - 图像状态
 * @param {Object} imageData - 图像数据 (这里 imageData.result 应该是图床 URL)
 * @param {Object} context - 会话上下文
 * @returns {string} Markdown格式的图像内容
 */
function createImageMarkdown(imageState: any, imageData: any, context: any): string {
    // 现在 imageData.result 应该是图床返回的 URL
    const markdownImage = `![Image](${imageData.result})`; // 直接使用 URL
    let content = `\n\n${markdownImage}\n\n**Prompt:** ${imageState.prompt}`;

    if (imageState.negative && imageState.negative.trim() !== '') {
        content += `\n**Negative Prompt:** ${imageState.negative}`;
    }

    // 添加生成信息，格式按照要求修改
    const elapsedTime = imageData.elapsed_time ? imageData.elapsed_time.toFixed(2) : '0.00';
    const creditLine = CONFIG.IMAGE.MESSAGES.CREDIT_FORMAT
        .replace('{model}', context.model)
        .replace('{time}', elapsedTime)
        .replace('{provider}', CONFIG.SERVICE.PROVIDER.NAME)
        .replace('{url}', CONFIG.SERVICE.PROVIDER.URL);

    content += `\n\n${creditLine}`;

    return content;
}


/**
 * 发送数据块到流
 * @param {ReadableStreamDefaultController} controller - 流控制器
 * @param {Object} context - 会话上下文
 * @param {string} content - 内容
 */
function sendChunk(
    controller: ReadableStreamDefaultController,
    context: any,
    content: string,
) {
    if (!content) return;

    const chunk = {
        id: `chatcmpl-${context.chatId}`,
        object: 'chat.completion.chunk',
        created: context.timestamp,
        model: context.model,
        choices: [
            {
                delta: { content },
                index: 0,
                finish_reason: null,
            },
        ],
    };

    controller.enqueue(encodeEventStreamChunk(chunk));
}

/**
 * 发送错误信息到流
 * @param {ReadableStreamDefaultController} controller - 流控制器
 * @param {Object} context - 会话上下文
 * @param {string} errorMessage - 错误信息
 */
function sendErrorChunk(
    controller: ReadableStreamDefaultController,
    context: any,
    errorMessage: string,
) {
    sendChunk(controller, context, `\n\n错误: ${errorMessage}`);
}

/**
 * 发送最终数据块到流
 * @param {ReadableStreamDefaultController} controller - 流控制器
 * @param {Object} context - 会话上下文
 */
function sendFinalChunk(controller: ReadableStreamDefaultController, context: any) {
    if (context.finalChunkSent) return; // 确保只发送一次

    const finalChunk = {
        id: `chatcmpl-${context.chatId}`,
        object: 'chat.completion.chunk',
        created: context.timestamp,
        model: context.model,
        choices: [
            {
                delta: {},
                index: 0,
                finish_reason: 'stop',
            },
        ],
    };
    controller.enqueue(encodeEventStreamChunk(finalChunk));
    controller.enqueue(encoder.encode('data: [DONE]\n\n'));
    context.finalChunkSent = true;
}

/**
 * 将对象编码为事件流块
 * @param {Object} data - 要编码的数据
 * @returns {Uint8Array} 编码后的数据
 */
function encodeEventStreamChunk(data: any): Uint8Array {
    return encoder.encode(`data: ${JSON.stringify(data)}\n\n`);
}

/**
 * 处理消息数据
 * @param {string} msgData - 原始消息数据
 * @returns {string} 处理后的消息数据
 */
function processMsgData(msgData: string): string {
    // 处理JSON字符串格式
    if (msgData.startsWith('"') && msgData.endsWith('"')) {
        try {
            // 使用JSON.parse处理转义
            return JSON.parse(msgData);
        } catch (e) {
            // 回退到手动处理
            return msgData.slice(1, -1).replace(/\\"/g, '"').replace(/\\n/g, '\n');
        }
    }
    return msgData.replace(/\\n/g, '\n');
}

/**
 * 获取图像状态
 * @param {string} jobId - 图像任务ID
 * @returns {Promise<Object|null>} 图像状态数据
 */
async function fetchImageStatus(jobId: string): Promise<any | null> {
    try {
        const endpoint =
            `${CONFIG.AKASH_API.BASE_URL}${CONFIG.AKASH_API.ENDPOINTS.IMAGE_STATUS}?ids=${jobId}`;
        const response = await fetchWithRetry(
            endpoint,
            { headers: AKASH_HEADERS },
            { retries: 1, delay: 500 },
        );

        if (!response.ok) {
            throw new ApiError(
                `Image status API responded with status ${response.status}`,
                response.status,
            );
        }

        const data = await response.json();
        return data && data.length > 0 ? data[0] : null;
    } catch (error) {
        Logger.error('Error fetching image status:', error);
        return null;
    }
}

/**
 * 轮询图像状态直到完成或超时
 * @param {string} jobId - 图像任务ID
 * @returns {Promise<Object|null>} 最终的图像状态数据
 */
async function pollImageStatus(jobId: string): Promise<any | null> {
    let attempts = 0;
    let lastStatus = null;

    while (attempts < CONFIG.IMAGE.MAX_POLL_ATTEMPTS) {
        const imageData = await fetchImageStatus(jobId);

        if (imageData) {
            // 如果状态变化，记录日志
            if (!lastStatus || lastStatus !== imageData.status) {
                Logger.debug(`图像状态更新: jobId=${jobId}, status=${imageData.status}`);
                lastStatus = imageData.status;
            }

            // 如果状态是已完成且有结果，返回数据
            if (imageData.status === CONFIG.STATUS_COMPLETED && imageData.result) {
                return imageData;
            }

            // 如果状态是失败，停止轮询
            if (imageData.status === CONFIG.STATUS_FAILED) {
                return imageData;
            }
        }

        // 等待指定时间后再次尝试
        await sleep(CONFIG.IMAGE.POLL_INTERVAL_MS);
        attempts++;
    }

    Logger.warn(`图像生成轮询超过最大尝试次数: jobId=${jobId}, attempts=${attempts}`);

    // 超过最大尝试次数，返回最后一次获取的数据
    const finalImageData = await fetchImageStatus(jobId);
    if (!finalImageData) {
        throw new Error(
            `超过最大轮询次数，且无法获取图像状态: jobId=${jobId}, attempts=${attempts}`,
        );
    }
    return finalImageData;
}

/**
 * 创建超时Promise
 * @param {number} ms - 超时毫秒数
 * @param {string} message - 超时消息
 * @returns {Promise<never>} 超时Promise
 */
function createTimeout(ms: number, message: string): Promise<never> {
    return new Promise((_, reject) => {
        setTimeout(() => reject(new Error(message)), ms);
    });
}

/**
 * 等待指定的毫秒数
 * @param {number} ms - 等待毫秒数
 * @returns {Promise<void>}
 */
function sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * 创建JSON响应
 * @param {Object} data - 响应数据
 * @param {Object} [options={}] - 响应选项
 * @param {number} [options.status=200] - HTTP状态码
 * @param {Object} [options.headers={}] - 额外的响应头
 * @returns {Response} 响应对象
 */
function createJsonResponse(
    data: any,
    { status = CONFIG.HTTP.OK, headers = {} } = {},
): Response {
    return new Response(JSON.stringify(data), {
        status,
        headers: {
            ...HEADERS.JSON,
            ...HEADERS.CORS,
            ...headers,
        },
    });
}

/**
 * 全局错误处理器
 * @param {Error} error - 捕获的错误
 * @returns {Response} 错误响应
 */
function handleGlobalError(error: any): Response {
    Logger.error('Unhandled error:', error);

    // 确定合适的状态码
    const status = error instanceof ApiError
        ? error.statusCode
        : CONFIG.HTTP.SERVER_ERROR;

    const errorResponse = {
        error: {
            message: `服务器错误: ${error.message}`,
            type: error.name || 'ServerError',
            code: status,
        },
    };

    return createJsonResponse(errorResponse, { status });
}

/**
 * 自定义API错误
 */
class ApiError extends Error {
    /**
     * @param {string} message - 错误消息
     * @param {number} statusCode - HTTP状态码
     */
    constructor(message: string, statusCode = CONFIG.HTTP.SERVER_ERROR) {
        super(message);
        this.name = 'ApiError';
        this.statusCode = statusCode;
    }
}

/**
 * 自定义验证错误
 */
class ValidationError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'ValidationError';
    }
}
